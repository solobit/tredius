{
  "name": "executive",
  "version": "0.2.8",
  "description": "exec for the lazy",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/zeekay/executive"
  },
  "keywords": [
    "exec",
    "child_process"
  ],
  "author": {
    "name": "Zach Kelling",
    "email": "zeekayy@gmail.com",
    "url": "http://whatit.is"
  },
  "license": "BSD",
  "readmeFilename": "README.md",
  "devDependencies": {
    "chai": "~1.6.0",
    "mocha": "~1.9.0"
  },
  "readme": "# executive\n\nAn easy to use wrapper around `child_process.spawn`, useful for Cakefiles and the like. Pipes `stdout`, `stderr` and `stdin` so you don't have to. Think of it as a streaming `child_process.exec` with a few extra goodies.\n\n## Usage\n\n```javascript\nvar exec = require('executive');\n\nexec('ls', function(err, out, code) {\n    // Done, no need to echo out as it's piped to stdout by default.\n});\n```\n\nArguments are parsed out properly for you:\n```javascript\nvar exec = require('executive');\n\nexec('ls -AGF Foo\\\\ bar', function(err, out, code) {\n    // Note the escaped folder name.\n});\n```\n\nAlso supports simple serial execution of commands:\n```javascript\nvar exec = require('executive');\n\nexec(['ls', 'ls', 'ls'], function(err, out, code) {\n    // All three ls commands are called in order.\n});\n```\n\nIn the case of a failure, no additional commands will be executed:\n```javascript\nexec(['ls', 'aaaaa', 'ls'], function(err, out, code) {\n    // First command succeeds, second blows up, third is never called.\n});\n```\n\n## Options\nOptions may be passed as the second argument to exec and in the case of `quiet`\nand `interactive` helper functions exist.\n\n```javascript\nexec('ls', {options: quiet})\n```\n\nand\n\n```javascript\nexec.quiet('ls')\n```\n\nare equivalent.\n\n#### options.interactive | exec.interactive\n##### default `false`\n\nIf you need to interact with a program (your favorite text editor for instance)\nor watch the output of a long running process (`tail -f`), or just don't care\nabout checking `stderr` and `stdout`, set `interactive` to `true`:\n\n```javascript\nexec.interactive('vim', function(err, out, code) {\n    // Edit your commit message or whatnot\n});\n```\n\n#### options.quiet | exec.quiet\n##### default `false`\n\nIf you'd prefer not to pipe `stdin`, `stdout`, `stderr` set `quiet` to `false`:\n```javascript\nexec.quiet(['ls', 'ls'], function(err, out, code) {\n    // Not a peep is heard, and both ls commands will be executed.\n});\n```\n\n#### options.safe\n##### default `true`\n\nIn case you need to ignore errors during serial execution it's possible to set\n`safe` to `false`:\n\n```javascript\nexec(['ls', 'aaaaaa', 'ls'], {safe: false}, function(err, out, code) {\n    // Both commands execute despite aaaaaa not being a valid executable.\n});\n```\n\n## Extra credit\nThe spawned child process object is accessible when you exec a single program\n(not available when using the simple serial execution wrapper):\n\n```javascript\nvar exec = require('executive');\n\nchild = exec.quiet('ls');\nchild.stdout.on('data', function(data) {\n    // Do your own thing\n});\n```\n\nIt's especially nice to use in a Cakefile:\n```coffeescript\nexec = require 'executive'\n\ntask 'package', 'Package project', ->\n  exec '''\n    mkdir -p dist\n    rm -rf dist/*\n    cp manifest.json dist\n    cp -rf assets dist\n    cp -rf lib dist\n    cp -rf views dist\n    zip -r package.zip dist\n    rm -rf dist\n  '''.split '\\n'\n```\n",
  "bugs": {
    "url": "https://github.com/zeekay/executive/issues"
  },
  "_id": "executive@0.2.8",
  "dist": {
    "shasum": "8d391fe0fe38b66b11487544e0d8bc94234cf0e2"
  },
  "_from": "executive@",
  "_resolved": "https://registry.npmjs.org/executive/-/executive-0.2.8.tgz"
}
